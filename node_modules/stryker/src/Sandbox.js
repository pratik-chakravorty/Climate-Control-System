"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var log4js_1 = require("log4js");
var mkdirp = require("mkdirp");
var core_1 = require("stryker-api/core");
var objectUtils_1 = require("./utils/objectUtils");
var ResilientTestRunnerFactory_1 = require("./isolated-runner/ResilientTestRunnerFactory");
var TempFolder_1 = require("./utils/TempFolder");
var fileUtils = require("./utils/fileUtils");
var TestableMutant_1 = require("./TestableMutant");
var Sandbox = /** @class */ (function () {
    function Sandbox(options, index, files, testFramework) {
        this.options = options;
        this.index = index;
        this.testFramework = testFramework;
        this.log = log4js_1.getLogger(Sandbox.name);
        this.testHooksFile = path.resolve('___testHooksForStryker.js');
        this.workingFolder = TempFolder_1.TempFolder.instance().createRandomFolder('sandbox');
        this.log.debug('Creating a sandbox for files in %s', this.workingFolder);
        this.files = files.slice(); // Create a copy
        if (testFramework) {
            this.testHooksFile = path.resolve('___testHooksForStryker.js');
            this.files.unshift({
                name: this.testHooksFile,
                content: '',
                mutated: false,
                included: true,
                transpiled: false,
                kind: core_1.FileKind.Text
            });
        }
    }
    Sandbox.prototype.initialize = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fillSandbox()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.initializeTestRunner()];
                }
            });
        });
    };
    Sandbox.create = function (options, index, files, testFramework) {
        var sandbox = new Sandbox(options, index, files, testFramework);
        return sandbox.initialize().then(function () { return sandbox; });
    };
    Sandbox.prototype.run = function (timeout) {
        return this.testRunner.run({ timeout: timeout });
    };
    Sandbox.prototype.dispose = function () {
        return this.testRunner.dispose() || Promise.resolve();
    };
    Sandbox.prototype.runMutant = function (transpiledMutant) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var mutantFiles, runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mutantFiles = transpiledMutant.transpileResult.outputFiles;
                        if (transpiledMutant.mutant.testSelectionResult === TestableMutant_1.TestSelectionResult.Failed) {
                            this.log.warn("Failed find coverage data for this mutant, running all tests. This might have an impact on performance: " + transpiledMutant.mutant.toString());
                        }
                        return [4 /*yield*/, Promise.all(mutantFiles.map(function (mutatedFile) { return _this.writeFileInSandbox(mutatedFile); }).concat(this.filterTests(transpiledMutant.mutant)))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.run(this.calculateTimeout(transpiledMutant.mutant))];
                    case 2:
                        runResult = _a.sent();
                        return [4 /*yield*/, this.reset(mutantFiles)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, runResult];
                }
            });
        });
    };
    Sandbox.prototype.reset = function (mutatedFiles) {
        var _this = this;
        var originalFiles = this.files.filter(function (originalFile) { return mutatedFiles.some(function (mutatedFile) { return mutatedFile.name === originalFile.name; }); });
        return Promise.all(originalFiles.map(function (file) {
            if (file.kind !== core_1.FileKind.Web) {
                return fileUtils.writeFile(_this.fileMap[file.name], file.content);
            }
            else {
                return Promise.resolve();
            }
        }));
    };
    Sandbox.prototype.writeFileInSandbox = function (file) {
        switch (file.kind) {
            case core_1.FileKind.Web:
                return Promise.resolve();
            default:
                var fileNameInSandbox = this.fileMap[file.name];
                return fileUtils.writeFile(fileNameInSandbox, file.content);
        }
    };
    Sandbox.prototype.fillSandbox = function () {
        var _this = this;
        this.fileMap = Object.create(null);
        var copyPromises = this.files
            .map(function (file) { return _this.fillFile(file); });
        return Promise.all(copyPromises);
    };
    Sandbox.prototype.fillFile = function (file) {
        switch (file.kind) {
            case core_1.FileKind.Web:
                this.fileMap[file.name] = file.name;
                return Promise.resolve();
            default:
                var cwd = process.cwd();
                var relativePath = path.relative(cwd, file.name);
                var folderName = path.join(this.workingFolder, path.dirname(relativePath));
                mkdirp.sync(folderName);
                var targetFile = path.join(folderName, path.basename(relativePath));
                this.fileMap[file.name] = targetFile;
                return fileUtils.writeFile(targetFile, file.content);
        }
    };
    Sandbox.prototype.initializeTestRunner = function () {
        var _this = this;
        var files = this.files.map(function (originalFile) { return ({
            name: _this.fileMap[originalFile.name],
            mutated: originalFile.mutated,
            included: originalFile.included,
            kind: originalFile.kind,
            transpiled: originalFile.transpiled
        }); });
        var settings = {
            files: files,
            strykerOptions: this.options,
            port: this.options.port + this.index,
            sandboxWorkingFolder: this.workingFolder
        };
        this.log.debug("Creating test runner %s using settings {port: %s}", this.index, settings.port);
        this.testRunner = ResilientTestRunnerFactory_1.default.create(settings.strykerOptions.testRunner || '', settings);
        return this.testRunner.init();
    };
    Sandbox.prototype.calculateTimeout = function (mutant) {
        var baseTimeout = mutant.timeSpentScopedTests;
        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;
    };
    Sandbox.prototype.filterTests = function (mutant) {
        if (this.testFramework) {
            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.selectedTests));
            return fileUtils.writeFile(this.fileMap[this.testHooksFile], fileContent);
        }
        else {
            return Promise.resolve(void 0);
        }
    };
    return Sandbox;
}());
exports.default = Sandbox;
//# sourceMappingURL=Sandbox.js.map